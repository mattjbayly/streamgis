# 4) compute shortest path (expects an edge weight column if you pass a name,
#    or omit `weights` to use unweighted shortest paths)
paths <- sfnetworks::st_network_paths(
network,
from    = node_idx_1,
to      = node_idx_2,
weights = "length"   # change/remove if you don't have a 'length' column on edges
)
network
node_idx_1
node_idx_2
streamlines
# Input validation
if (!inherits(streamlines, "sf")) {
stop("`streamlines` must be an sf object (LINESTRING/MULTILINESTRING).")
}
if (!inherits(point_1, "sf") || nrow(point_1) != 1) {
stop("`point_1` must be an sf object with exactly 1 feature.")
}
if (!inherits(point_2, "sf") || nrow(point_2) != 1) {
stop("`point_2` must be an sf object with exactly 1 feature.")
}
if (nrow(streamlines) < 1) {
stop("`streamlines` is empty.")
}
# Ensure same CRS
if (!identical(sf::st_crs(streamlines), sf::st_crs(point_1))) {
point_1 <- sf::st_transform(point_1, sf::st_crs(streamlines))
}
if (!identical(sf::st_crs(streamlines), sf::st_crs(point_2))) {
point_2 <- sf::st_transform(point_2, sf::st_crs(streamlines))
}
# Add length column to stream
streamlines$length_m <- NULL
streamlines$length_m <- as.numeric(sf::st_length(streamlines))
# Step 1: Snap points to nearest streamlines
snapped_pt1 <- snap_point_to_streamline(streamlines, point_1)
snapped_pt2 <- snap_point_to_streamline(streamlines, point_2)
# Step 2: Create network from streamlines
network <- create_stream_network(streamlines)
# Step 3: Find shortest path on network
path_edges <- find_shortest_path_network(network, snapped_pt1, snapped_pt2)
# 1) nodes as sf
nodes <- network %>% sfnetworks::activate(nodes) %>% sf::st_as_sf()
# 2) get the snapped points (sf POINT)
pt1 <- snapped_pt1$point
pt2 <- snapped_pt2$point
# 3) nearest node indices (faster/safer than full distance matrix)
node_idx_1 <- as.integer(sf::st_nearest_feature(pt1, nodes))
node_idx_2 <- as.integer(sf::st_nearest_feature(pt2, nodes))
# 4) compute shortest path (expects an edge weight column if you pass a name,
#    or omit `weights` to use unweighted shortest paths)
paths <- sfnetworks::st_network_paths(
network,
from    = node_idx_1,
to      = node_idx_2,
weights = "length_m"   # change/remove if you don't have a 'length' column on edges
)
# 5) check path and extract node indices
if (nrow(paths) == 0 || length(paths$node_paths[[1]]) == 0) {
stop("No path found between the two points on the network.")
}
idx <- paths$node_paths[[1]]
# 6) return the nodes along the path (ordered)
path_nodes_sf <- nodes[idx, , drop = FALSE]
path_nodes_sf
plot(st_geometry(path_nodes_sf))
plot(st_geometry(path_nodes_sf), type = 'l')
#' Helper: Find shortest path between two points on network (returns NODES as sf)
#' @keywords internal
find_shortest_path_network_nodes <- function(network, snapped_pt1, snapped_pt2) {
# 1) nodes as sf
nodes <- network %>% sfnetworks::activate(nodes) %>% sf::st_as_sf()
# 2) get the snapped points (sf POINT)
pt1 <- snapped_pt1$point
pt2 <- snapped_pt2$point
# 3) nearest node indices (faster/safer than full distance matrix)
node_idx_1 <- as.integer(sf::st_nearest_feature(pt1, nodes))
node_idx_2 <- as.integer(sf::st_nearest_feature(pt2, nodes))
# 4) compute shortest path (expects an edge weight column if you pass a name,
#    or omit `weights` to use unweighted shortest paths)
paths <- sfnetworks::st_network_paths(
network,
from    = node_idx_1,
to      = node_idx_2,
weights = "length_m"   # change/remove if you don't have a 'length' column on edges
)
# 5) check path and extract node indices
if (nrow(paths) == 0 || length(paths$node_paths[[1]]) == 0) {
stop("No path found between the two points on the network.")
}
idx <- paths$node_paths[[1]]
# 6) return the nodes along the path (ordered)
path_nodes_sf <- nodes[idx, , drop = FALSE]
path_nodes_sf
}
#' Helper: Extract and clip path segments from original streamlines
#'
#' @keywords internal
extract_path_segments <- function(streamlines, snapped_pt1, snapped_pt2, path_edges) {
streamlines_cast <- suppressWarnings(sf::st_cast(streamlines, "LINESTRING"))
# Get the snapped points
pt1 <- snapped_pt1$point
pt2 <- snapped_pt2$point
line_idx_1 <- snapped_pt1$line_idx
line_idx_2 <- snapped_pt2$line_idx
# Start with segments in the path
all_segments <- list()
segment_count <- 1
# Process each edge in the path
for (edge_id in path_edges) {
# Get the original line for this edge
original_line <- streamlines_cast[edge_id, ]
# Check if this is the start, end, or middle segment
if (edge_id == line_idx_1) {
# Start segment: clip from snapped point to end
clipped_line <- clip_line_from_point(original_line, pt1, clip_start = TRUE)
} else if (edge_id == line_idx_2) {
# End segment: clip from start to snapped point
clipped_line <- clip_line_from_point(original_line, pt2, clip_start = FALSE)
} else {
# Middle segment: keep whole
clipped_line <- original_line
}
if (!is.null(clipped_line)) {
all_segments[[segment_count]] <- clipped_line
segment_count <- segment_count + 1
}
}
if (length(all_segments) == 0) {
stop("No segments extracted from the path.")
}
# Combine all segments
result <- do.call(rbind, all_segments)
result <- sf::st_cast(sf::st_union(result), "LINESTRING")
# Preserve original attributes if needed (merge from all original lines in path)
if (length(all_segments) > 0) {
# Return the first segment's attributes merged
result <- streamlines_cast[path_edges[1], ]
result$geometry <- sf::st_union(do.call(c, lapply(all_segments, sf::st_geometry)))
}
return(result)
}
#' Helper: Clip a line at a snapped point
#'
#' @keywords internal
clip_line_from_point <- function(line, point, clip_start = TRUE) {
# Find the distance along the line to the point
coords <- sf::st_coordinates(line)
pt_coords <- sf::st_coordinates(point)
# Calculate cumulative distance along the line
if (nrow(coords) < 2) return(NULL)
segments <- coords[-nrow(coords), , drop = FALSE] - coords[-1, , drop = FALSE]
seg_lengths <- sqrt(rowSums(segments^2))
cum_dist <- c(0, cumsum(seg_lengths))
# Find which segment the point is on
point_vec <- pt_coords[1, 1:2]
min_dist <- Inf
min_idx <- 1
for (i in 1:(nrow(coords) - 1)) {
# Distance from point to segment
p1 <- coords[i, 1:2]
p2 <- coords[i + 1, 1:2]
# Project point onto segment
seg_vec <- p2 - p1
seg_len_sq <- sum(seg_vec^2)
if (seg_len_sq > 0) {
t <- max(0, min(1, sum((point_vec - p1) * seg_vec) / seg_len_sq))
proj_point <- p1 + t * seg_vec
dist <- sqrt(sum((point_vec - proj_point)^2))
if (dist < min_dist) {
min_dist <- dist
min_idx <- i
}
}
}
# Split the line at the point
if (clip_start) {
# Keep from point to end
new_coords <- coords[min_idx:nrow(coords), , drop = FALSE]
} else {
# Keep from start to point
new_coords <- coords[1:min_idx, , drop = FALSE]
}
if (nrow(new_coords) < 2) return(NULL)
# Create new linestring
new_line <- sf::st_linestring(new_coords[, 1:2])
return(sf::st_sf(geometry = sf::st_sfc(new_line, crs = sf::st_crs(line))))
}
#' Extract Path Between Two Points on Stream Network
#'
#' @description Snaps two spatial points to the nearest streamline, finds the shortest path
#' between them on the stream network using `sfnetworks`, clips the streamline layer at the
#' point intersections, and extracts the line segments between the two points.
#'
#' @details
#' This function performs the following steps:
#'   1. Snaps `point_1` and `point_2` to the nearest streamlines
#'   2. Creates a network from the streamlines using `sfnetworks`
#'   3. Finds the shortest path between the snapped points on the network
#'   4. Clips the original streamline segments at the intersection points
#'   5. Extracts and returns the line segments forming the shortest path
#'
#' The function preserves original attributes from the `streamlines` attribute table
#' for all segments in the returned path.
#'
#' @param streamlines An `sf` LINESTRING/MULTILINESTRING object representing the stream network.
#' @param point_1 An `sf` POINT object (single feature).
#' @param point_2 An `sf` POINT object (single feature).
#'
#' @returns An `sf` LINESTRING object containing the stream segments forming the shortest path
#' between the two snapped points. Attributes from the original `streamlines` are preserved.
#'
#' @examples
#' \dontrun{
#' fname <- system.file("extdata", "/clip_points/clip_points.gpkg", package = "streamgis")
#' clip_points <- sf::st_read(fname)
#' fname <- system.file("extdata", "/clip_points/clip_lines.gpkg", package = "streamgis")
#' clip_lines <- sf::st_read(fname)
#'
#' clip_pts_target <- clip_points[clip_points$NAME == "PEP8", ]
#' point_1 <- clip_pts_target[1, ]
#' point_2 <- clip_pts_target[2, ]
#'
#' path <- extract_stream_path(clip_lines, point_1, point_2)
#' plot(sf::st_geometry(clip_lines))
#' plot(sf::st_geometry(path), col = "red", lwd = 2, add = TRUE)
#' }
#'
#' @export
#' @importFrom sf st_nearest_feature st_distance st_snap st_cast st_length
#' @importFrom sf st_geometry st_crs st_set_crs st_coordinates st_linestring
#' @importFrom sf st_sfc st_as_sf st_difference st_intersection st_union
#' @importFrom sfnetworks as_sfnetwork st_network_paths
#' @importFrom dplyr filter tibble
extract_stream_path <- function(streamlines, point_1, point_2) {
# streamlines <- clip_lines
# point_1
# point_2
# Input validation
if (!inherits(streamlines, "sf")) {
stop("`streamlines` must be an sf object (LINESTRING/MULTILINESTRING).")
}
if (!inherits(point_1, "sf") || nrow(point_1) != 1) {
stop("`point_1` must be an sf object with exactly 1 feature.")
}
if (!inherits(point_2, "sf") || nrow(point_2) != 1) {
stop("`point_2` must be an sf object with exactly 1 feature.")
}
if (nrow(streamlines) < 1) {
stop("`streamlines` is empty.")
}
# Ensure same CRS
if (!identical(sf::st_crs(streamlines), sf::st_crs(point_1))) {
point_1 <- sf::st_transform(point_1, sf::st_crs(streamlines))
}
if (!identical(sf::st_crs(streamlines), sf::st_crs(point_2))) {
point_2 <- sf::st_transform(point_2, sf::st_crs(streamlines))
}
# Add length column to stream
streamlines$length_m <- NULL
streamlines$length_m <- as.numeric(sf::st_length(streamlines))
# Step 1: Snap points to nearest streamlines
snapped_pt1 <- snap_point_to_streamline(streamlines, point_1)
snapped_pt2 <- snap_point_to_streamline(streamlines, point_2)
# Step 2: Create network from streamlines
network <- create_stream_network(streamlines)
# Step 3: Find shortest path on network
path_edges <- find_shortest_path_network(network, snapped_pt1, snapped_pt2)
# Step 4: Extract line segments from original streamlines based on path
result <- extract_path_segments(streamlines, snapped_pt1, snapped_pt2, path_edges)
return(result)
}
#' Helper: Snap a single point to nearest streamline
#'
#' @keywords internal
snap_point_to_streamline <- function(streamlines, point) {
# Find nearest streamline
nearest_idx <- sf::st_nearest_feature(point, streamlines)
nearest_line <- streamlines[nearest_idx, ]
# Snap point to the nearest line
snapped <- sf::st_snap(point, nearest_line, tolerance = Inf)
# Return both the snapped point and its index
list(point = snapped, line_idx = nearest_idx, original_line = nearest_line)
}
#' Helper: Create sfnetwork from streamlines
#'
#' @keywords internal
create_stream_network <- function(streamlines) {
# Cast to LINESTRING (handling MULTILINESTRING)
streamlines_cast <- suppressWarnings(sf::st_cast(streamlines, "LINESTRING"))
# Create network
network <- sfnetworks::as_sfnetwork(streamlines_cast, directed = FALSE)
return(network)
}
#' Helper: Find shortest path between two points on network (returns NODES as sf)
#' @keywords internal
find_shortest_path_network_nodes <- function(network, snapped_pt1, snapped_pt2) {
# 1) nodes as sf
nodes <- network %>% sfnetworks::activate(nodes) %>% sf::st_as_sf()
# 2) get the snapped points (sf POINT)
pt1 <- snapped_pt1$point
pt2 <- snapped_pt2$point
# 3) nearest node indices (faster/safer than full distance matrix)
node_idx_1 <- as.integer(sf::st_nearest_feature(pt1, nodes))
node_idx_2 <- as.integer(sf::st_nearest_feature(pt2, nodes))
# 4) compute shortest path (expects an edge weight column if you pass a name,
#    or omit `weights` to use unweighted shortest paths)
paths <- sfnetworks::st_network_paths(
network,
from    = node_idx_1,
to      = node_idx_2,
weights = "length_m"   # change/remove if you don't have a 'length' column on edges
)
# 5) check path and extract node indices
if (nrow(paths) == 0 || length(paths$node_paths[[1]]) == 0) {
stop("No path found between the two points on the network.")
}
idx <- paths$node_paths[[1]]
# 6) return the nodes along the path (ordered)
path_nodes_sf <- nodes[idx, , drop = FALSE]
path_nodes_sf
}
#' Helper: Extract and clip path segments from original streamlines
#'
#' @keywords internal
extract_path_segments <- function(streamlines, snapped_pt1, snapped_pt2, path_edges) {
streamlines_cast <- suppressWarnings(sf::st_cast(streamlines, "LINESTRING"))
# Get the snapped points
pt1 <- snapped_pt1$point
pt2 <- snapped_pt2$point
line_idx_1 <- snapped_pt1$line_idx
line_idx_2 <- snapped_pt2$line_idx
# Start with segments in the path
all_segments <- list()
segment_count <- 1
# Process each edge in the path
for (edge_id in path_edges) {
# Get the original line for this edge
original_line <- streamlines_cast[edge_id, ]
# Check if this is the start, end, or middle segment
if (edge_id == line_idx_1) {
# Start segment: clip from snapped point to end
clipped_line <- clip_line_from_point(original_line, pt1, clip_start = TRUE)
} else if (edge_id == line_idx_2) {
# End segment: clip from start to snapped point
clipped_line <- clip_line_from_point(original_line, pt2, clip_start = FALSE)
} else {
# Middle segment: keep whole
clipped_line <- original_line
}
if (!is.null(clipped_line)) {
all_segments[[segment_count]] <- clipped_line
segment_count <- segment_count + 1
}
}
if (length(all_segments) == 0) {
stop("No segments extracted from the path.")
}
# Combine all segments
result <- do.call(rbind, all_segments)
result <- sf::st_cast(sf::st_union(result), "LINESTRING")
# Preserve original attributes if needed (merge from all original lines in path)
if (length(all_segments) > 0) {
# Return the first segment's attributes merged
result <- streamlines_cast[path_edges[1], ]
result$geometry <- sf::st_union(do.call(c, lapply(all_segments, sf::st_geometry)))
}
return(result)
}
#' Helper: Clip a line at a snapped point
#'
#' @keywords internal
clip_line_from_point <- function(line, point, clip_start = TRUE) {
# Find the distance along the line to the point
coords <- sf::st_coordinates(line)
pt_coords <- sf::st_coordinates(point)
# Calculate cumulative distance along the line
if (nrow(coords) < 2) return(NULL)
segments <- coords[-nrow(coords), , drop = FALSE] - coords[-1, , drop = FALSE]
seg_lengths <- sqrt(rowSums(segments^2))
cum_dist <- c(0, cumsum(seg_lengths))
# Find which segment the point is on
point_vec <- pt_coords[1, 1:2]
min_dist <- Inf
min_idx <- 1
for (i in 1:(nrow(coords) - 1)) {
# Distance from point to segment
p1 <- coords[i, 1:2]
p2 <- coords[i + 1, 1:2]
# Project point onto segment
seg_vec <- p2 - p1
seg_len_sq <- sum(seg_vec^2)
if (seg_len_sq > 0) {
t <- max(0, min(1, sum((point_vec - p1) * seg_vec) / seg_len_sq))
proj_point <- p1 + t * seg_vec
dist <- sqrt(sum((point_vec - proj_point)^2))
if (dist < min_dist) {
min_dist <- dist
min_idx <- i
}
}
}
# Split the line at the point
if (clip_start) {
# Keep from point to end
new_coords <- coords[min_idx:nrow(coords), , drop = FALSE]
} else {
# Keep from start to point
new_coords <- coords[1:min_idx, , drop = FALSE]
}
if (nrow(new_coords) < 2) return(NULL)
# Create new linestring
new_line <- sf::st_linestring(new_coords[, 1:2])
return(sf::st_sf(geometry = sf::st_sfc(new_line, crs = sf::st_crs(line))))
}
fname <- system.file("extdata", "/clip_points/clip_points.gpkg", package = "streamgis")
clip_points <- sf::st_read(fname)
class(clip_lines)
fname <- system.file("extdata", "/clip_points/clip_lines.gpkg", package = "streamgis")
clip_lines <- sf::st_read(fname)
class(clip_lines)
# Clip streams for PEP8
# Get clip points for PEP8
clip_pts_target <- clip_points[clip_points$NAME == "PEP8", ]
nrow(clip_pts_target) # should be 2
point_1 <- clip_pts_target[1, ]
point_2 <- clip_pts_target[2, ]
path <- extract_stream_path(clip_lines, point_1, point_2)
#----------------------------------------------------
# Build and Tests
#----------------------------------------------------
library(usethis)
library(testthat)
library(rhub)
library(devtools)
library(qpdf)
library(kableExtra)
library(testthat)
# usethis::use_roxygen_md()     # once per package (if not already)
# Loading unfinished package to memory...
rm(list = ls())
devtools::load_all()
devtools::document()
# Import a simple stream
fname <- system.file("extdata", "/clip_points/clip_points.gpkg", package = "streamgis")
clip_points <- sf::st_read(fname)
class(clip_lines)
fname <- system.file("extdata", "/clip_points/clip_lines.gpkg", package = "streamgis")
clip_lines <- sf::st_read(fname)
# Import a simple stream
fname <- system.file("extdata", "/clip_points/clip_points.gpkg", package = "streamgis")
clip_points <- sf::st_read(fname)
class(clip_lines)
fname <- system.file("extdata", "/clip_points/clip_lines.gpkg", package = "streamgis")
clip_lines <- sf::st_read(fname)
class(clip_lines)
# Clip streams for PEP8
# Get clip points for PEP8
clip_pts_target <- clip_points[clip_points$NAME == "PEP8", ]
nrow(clip_pts_target) # should be 2
point_1 <- clip_pts_target[1, ]
point_2 <- clip_pts_target[2, ]
path <- extract_stream_path(clip_lines, point_1, point_2)
library(usethis)
library(testthat)
library(rhub)
library(devtools)
library(qpdf)
library(kableExtra)
library(testthat)
# usethis::use_roxygen_md()     # once per package (if not already)
# Loading unfinished package to memory...
rm(list = ls())
devtools::load_all()
devtools::document()
# Import a simple stream
fname <- system.file("extdata", "/clip_points/clip_points.gpkg", package = "streamgis")
clip_points <- sf::st_read(fname)
class(clip_lines)
# Import a simple stream
fname <- system.file("extdata", "/clip_points/clip_points.gpkg", package = "streamgis")
clip_points <- sf::st_read(fname)
class(clip_lines)
# Import a simple stream
fname <- system.file("extdata", "/clip_points/clip_points.gpkg", package = "streamgis")
clip_points <- sf::st_read(fname)
fname
class(clip_lines)
# Import a simple stream
fname <- system.file("extdata", "/clip_points/clip_points.gpkg", package = "streamgis")
clip_points <- sf::st_read(fname)
class(clip_points)
fname <- system.file("extdata", "/clip_points/clip_lines.gpkg", package = "streamgis")
clip_lines <- sf::st_read(fname)
class(clip_lines)
# Clip streams for PEP8
# Get clip points for PEP8
clip_pts_target <- clip_points[clip_points$NAME == "PEP8", ]
nrow(clip_pts_target) # should be 2
point_1 <- clip_pts_target[1, ]
point_2 <- clip_pts_target[2, ]
path <- extract_stream_path(clip_lines, point_1, point_2)
# Load dependencies
library(sf)
library(usethis)
library(testthat)
library(rhub)
library(devtools)
library(qpdf)
library(kableExtra)
library(testthat)
