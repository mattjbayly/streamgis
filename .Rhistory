buff_margin <- sf::st_cast(buffer_raw, "LINESTRING")
buff_margin <- sf::st_buffer(buff_margin, 0.1)
# Start point on line
int <- sf::st_intersects(pt_start, buff_margin)
int <- lapply(int, length)
int <- unlist(int)
any(int == 0)
csl_fix <- csl_fix[int == 1, ]
plot(st_geometry(csl_fix))
# End point on line
int <- sf::st_intersects(pt_end, buff_margin)
int <- lapply(int, length)
int <- unlist(int)
int <- unlist(int)
csl_fix <- csl_fix[int == 1, ]
plot(st_geometry(csl_fix))
mapview(buff_diss) + mapview(csl_fix)
# Only keep valid cross sections
csl_fix <- cross_section_lines
build_list <- list()
# New buffer object
buff_diss <- buffer_raw
# Trim long tails on cross sections
csl_fix <- sf::st_intersection(csl_fix, buffer_raw)
# Convert multipart to single part
csl_fix <- sf::st_cast(csl_fix, "MULTILINESTRING")
csl_fix <- sf::st_cast(csl_fix, "LINESTRING")
# Drop segments not crossing centerline
int <- sf::st_intersects(csl_fix, center_line)
int <- lapply(int, length)
int <- unlist(int)
csl_fix <- csl_fix[int == 1, ]
# Drop line segments with start end points
pt_start <- lwgeom::st_startpoint(csl_fix)
pt_end <- lwgeom::st_endpoint(csl_fix)
buff_margin <- sf::st_cast(buffer_raw, "LINESTRING")
buff_margin <- sf::st_buffer(buff_margin, 0.1)
# Start point on line
int <- sf::st_intersects(pt_start, buff_margin)
int <- lapply(int, length)
int <- unlist(int)
csl_fix <- csl_fix[int == 1, ]
# End point on line
int <- sf::st_intersects(pt_end, buff_margin)
int <- lapply(int, length)
int <- unlist(int)
csl_fix <- csl_fix[int == 1, ]
mapview(buff_margin) + mapview(csl_fix)
any(int == 0)
mapview(buff_margin) + mapview(pt_start) + mapview(pt_end)
# Only keep valid cross sections
csl_fix <- cross_section_lines
build_list <- list()
# New buffer object
buff_diss <- buffer_raw
# Trim long tails on cross sections
csl_fix <- sf::st_intersection(csl_fix, buffer_raw)
# Convert multipart to single part
csl_fix <- sf::st_cast(csl_fix, "MULTILINESTRING")
csl_fix <- sf::st_cast(csl_fix, "LINESTRING")
# Drop segments not crossing centerline
int <- sf::st_intersects(csl_fix, center_line)
int <- lapply(int, length)
int <- unlist(int)
nrow(csl_fix)
csl_fix <- csl_fix[which(int == 1), ]
nrow(csl_fix)
# Drop line segments with start end points
pt_start <- lwgeom::st_startpoint(csl_fix)
pt_end <- lwgeom::st_endpoint(csl_fix)
buff_margin <- sf::st_cast(buffer_raw, "LINESTRING")
buff_margin <- sf::st_buffer(buff_margin, 0.1)
# Start point on line
int <- sf::st_intersects(pt_start, buff_margin)
int <- lapply(int, length)
int <- unlist(int)
csl_fix <- csl_fix[which(int == 1), ]
nrow(csl_fix)
# End point on line
int <- sf::st_intersects(pt_end, buff_margin)
int <- lapply(int, length)
int <- unlist(int)
any(int == 0)
csl_fix <- csl_fix[which(int == 1), ]
# Only keep valid cross sections
csl_fix <- cross_section_lines
build_list <- list()
# New buffer object
buff_diss <- buffer_raw
# Trim long tails on cross sections
csl_fix <- sf::st_intersection(csl_fix, buffer_raw)
nrow(csl_fix)
# Convert multipart to single part
csl_fix <- sf::st_cast(csl_fix, "MULTILINESTRING")
csl_fix <- sf::st_cast(csl_fix, "LINESTRING")
# Drop segments not crossing centerline
int <- sf::st_intersects(csl_fix, center_line)
int <- lapply(int, length)
int <- unlist(int)
csl_fix <- csl_fix[which(int == 1), ]
nrow(csl_fix)
# Drop line segments with start end points
buff_margin <- sf::st_cast(buffer_raw, "LINESTRING")
buff_margin <- sf::st_buffer(buff_margin, 0.1)
# Start point on line
pt_start <- lwgeom::st_startpoint(csl_fix)
int <- sf::st_intersects(pt_start, buff_margin)
int <- lapply(int, length)
int <- unlist(int)
csl_fix <- csl_fix[which(int == 1), ]
nrow(csl_fix)
# End point on line
pt_end <- lwgeom::st_endpoint(csl_fix)
int <- sf::st_intersects(pt_end, buff_margin)
int <- lapply(int, length)
int <- unlist(int)
any(int == 0)
csl_fix <- csl_fix[which(int == 1), ]
nrow(csl_fix)
mapview(buffer_raw) + mapview(csl_fix)
#--------------------------------------
library(devtools)
# =====================================
# Rebuild Package
rm(list = ls())
devtools::load_all()
devtools::document()
devtools::test()  # Run tests
# =====================================
# Remove and re install package locally
# Ctrl + Shift + F10 to restart RStudio
remove.packages("streamgis")
# =====================================
# Remove and re install package locally
# Ctrl + Shift + F10 to restart RStudio
remove.packages("streamgis")
# Re-build the R-Package after changes
#--------------------------------------
library(devtools)
# =====================================
# Rebuild Package
rm(list = ls())
devtools::load_all()
devtools::document()
devtools::check(vignettes = FALSE, manual = FALSE) # Operating system test
library(streamgis)
# Import BCFWA streamlines from FWA_STREAM_NETWORKS_SP.gdb
# Find target group code (layer) for area of interest (e.g., 'LNIC')
# center_line <- st_read("./path/to/BCFWA/FWA_STREAM_NETWORKS_SP.gdb",
layer = "LNIC")
library(streamgis)
# Import BCFWA streamlines from FWA_STREAM_NETWORKS_SP.gdb
# Find target group code (layer) for area of interest (e.g., 'LNIC')
# center_line <- st_read("./path/to/BCFWA/FWA_STREAM_NETWORKS_SP.gdb",
layer = "LNIC")
# or continue with default provided for tutorial
library(streamgis)
# Import BCFWA streamlines from FWA_STREAM_NETWORKS_SP.gdb
# Find target group code (layer) for area of interest (e.g., 'LNIC')
# center_line <- st_read("./path/to/BCFWA/FWA_STREAM_NETWORKS_SP.gdb",
# layer = "LNIC")
# or continue with default provided for tutorial
fname <- system.file("extdata", "bcfwa.gpkg", package="streamgis")
bcfwa <- sf::st_read(fname)
ds <- bcfwa_geometry(bcfwa = bcfwa,
upstream = 701794363,
downstream = 701773410,
epsg = 26910)
# ds_path: is the original geometry
# coordinates: is the x,y,z coordinates
names(ds)
# View the GIS data
plot(sf::st_geometry(ds$ds_path))
# View coordinates for longitudial profile
df <- ds$coordinates
plot(df$us_distance_m/1000, df$Z, type = 'l',
xlab = "Upstream Distance (km)", ylab = "Elevation (m)")
# Beginning of line
head(df, 3)
# End of line
tail(df, 3)
bcfwa
upstream = 701794363
downstream = 701773410
epsg = 26910
bcfwa$FWA_WATERSHED_CODE <- as.character(bcfwa$FWA_WATERSHED_CODE)
bcfwa$LOCAL_WATERSHED_CODE <- as.character(bcfwa$LOCAL_WATERSHED_CODE)
bcfwa <- bcfwa[!(is.na(bcfwa$FWA_WATERSHED_CODE)), ]
bcfwa <- bcfwa[!(is.na(bcfwa$LOCAL_WATERSHED_CODE)), ]
bcfwa <- bcfwa[!(grepl("999-999999$", bcfwa$FWA_WATERSHED_CODE)), ]
bcfwa <- bcfwa[!(grepl("999-999999$", bcfwa$LOCAL_WATERSHED_CODE)), ]
# Local UTM zone
bcfwa <- sf::st_transform(bcfwa, epsg)
int <- sf::st_intersects(nodes)
# Drop any isolated segments
bcfwa$FWA_WATERSHED_CODE <- as.character(bcfwa$FWA_WATERSHED_CODE)
bcfwa$LOCAL_WATERSHED_CODE <- as.character(bcfwa$LOCAL_WATERSHED_CODE)
bcfwa <- bcfwa[!(is.na(bcfwa$FWA_WATERSHED_CODE)), ]
bcfwa <- bcfwa[!(is.na(bcfwa$LOCAL_WATERSHED_CODE)), ]
bcfwa <- bcfwa[!(grepl("999-999999$", bcfwa$FWA_WATERSHED_CODE)), ]
bcfwa <- bcfwa[!(grepl("999-999999$", bcfwa$LOCAL_WATERSHED_CODE)), ]
# Local UTM zone
bcfwa <- sf::st_transform(bcfwa, epsg)
bcfwa <-
suppressWarnings({
sf::st_cast(bcfwa, "MULTILINESTRING")
})
bcfwa <-
suppressWarnings({
sf::st_cast(bcfwa, "LINESTRING")
})
# Add on line reach id (rid)
bcfwa$rid <- 1:nrow(bcfwa)
bcfwa$lfid <- bcfwa$LINEAR_FEATURE_ID
# Drop z geometry
bcfwa_bu <- bcfwa
# Use end point to start at upstream side
nodes <- lwgeom::st_endpoint(bcfwa_bu)
nodes <- sf::st_as_sf(nodes)
# add on ID fields
nodes$rid <- bcfwa_bu$rid
nodes$lfid <- bcfwa_bu$lfid
nodes$name <- bcfwa_bu$rid
int <- sf::st_intersects(nodes)
int <- lapply(int, length)
int <- unlist(int)
if (max(int) > 1) {
stop("Line draw direction variables. Some segments backwards")
}
# Build SF network
net <- sfnetworks::as_sfnetwork(bcfwa_bu, directed = FALSE) %>%
sfnetworks::activate("edges") %>%
dplyr::mutate(weight = sfnetworks::edge_length())
?activate
# Build SF network
net <- sfnetworks::as_sfnetwork(bcfwa_bu, directed = FALSE)
net <- sfnetworks::activate(net, "edges")
# Build SF network
net <- sfnetworks::as_sfnetwork(bcfwa_bu, directed = FALSE)
net <- sfnetworks::activate(net, "edges")
net <- dplyr::mutate(net, weight = sfnetworks::edge_length())
# Downstream point
if(class(downstream)[1] %in% c("numeric", "character")) {
from_pt_ds <- nodes[nodes$lfid == downstream, ]
from_pt_ds <- from_pt_ds[1, ]
} else {
# spatial
from_pt_ds <- downstream
}
# Upstream point
if(class(upstream)[1] %in% c("numeric", "character")) {
to_pt_us <- nodes[nodes$lfid == upstream, ]
to_pt_us <- to_pt_us[1, ]
} else {
# spatial
to_pt_us <- upstream
}
# Find shortest path
path <- sfnetworks::st_network_paths(net,
from = from_pt_ds,
to = to_pt_us)
ds_route_ids <- path$edge_paths[[1]]
ds_route <- bcfwa_bu[ds_route_ids, ]
# Get route geometry
coords <- sf::st_coordinates(ds_route)
coords <- as.data.frame(coords)
# Calculate Cartesian distance between points
coords$dist <- NA
n <- nrow(coords)
coords$dist[2:n] <- sqrt(((coords$X[2:n] - coords$X[1:n-1]) ^ 2) +
((coords$Y[2:n] - coords$Y[1:n-1]) ^ 2))
# Cumulative upstream distance
coords$dist <- ifelse(is.na(coords$dist), 0, coords$dist)
coords$us_distance_m <- cumsum(coords$dist)
s1 <- sum(coords$dist, na.rm = TRUE)
s2 <- as.numeric(sum(sf::st_length(ds_route)))
diff <- abs(1 - s1/s2)
if(diff > 0.05) {
warning("Cumulative length error greater than 5%...")
}
# Build return object
ret_obj <- list()
ret_obj$ds_path <- ds_route
ret_obj$coordinates <- coords
# or continue with default provided for tutorial
fname <- system.file("extdata", "bcfwa.gpkg", package="streamgis")
bcfwa <- sf::st_read(fname)
ds <- bcfwa_geometry(bcfwa = bcfwa,
upstream = 701794363,
downstream = 701773410,
epsg = 26910)
# ds_path: is the original geometry
# coordinates: is the x,y,z coordinates
names(ds)
# Check names
names(ds)
expect_true(all(names(ds) == c("ds_path", "coordinates")))
# View the GIS data
plot(sf::st_geometry(ds$ds_path))
class(ds$ds_path)
expect_true(all(class(ds$ds_path) == c("sf", "data.frame")))
# View coordinates for longitudial profile
df <- ds$coordinates
plot(df$us_distance_m/1000, df$Z, type = 'l',
xlab = "Upstream Distance (km)", ylab = "Elevation (m)")
# View coordinates for longitudial profile
df <- ds$coordinates
tail(df, 3)
# View coordinates for longitudial profile
df <- ds$coordinates
df$us_distance_m
tail(df$us_distance_m)[1]
dist1 <- as.numeric(sf::st_length(ds$ds_path))
# View coordinates for longitudial profile
df <- ds$coordinates
dist1 <- tail(df$us_distance_m)[1]
dist2 <- as.numeric(sf::st_length(ds$ds_path))
dist1
dist2
# View coordinates for longitudial profile
df <- ds$coordinates
dist1 <- tail(df$us_distance_m)[1]
dist2 <- sum(as.numeric(sf::st_length(ds$ds_path)))
dist1
dist2
abs(1 - dist1/dist2)
expect_true(diff < 0.05)
# Import a simple stream center line
# center_line <- st_read("./path/to/my/file.gpkg", layer = "layer name")
# or use default provided for tutorial
fname <- system.file("extdata", "center_line.gpkg", package="streamgis")
center_line <- sf::st_read(fname)
# Sample points along line
pol <- suppressWarnings({ points_on_line(center_line,
point_spacing = 100) })
# Do distances make sense
diff <- pol$distance_m[6] - pol$distance_m[5]
expect_true(round(diff, 0) == 100)
# Do points start at origin
expect_true(round(pol$distance_m[2], 0) == 100)
csl <- cross_section_lines(center_line = center_line,
points = pol,
cross_profile_length = 250,
epsg = 26910)
# Test that total profile legnth is reasonable
total_length <- as.numeric(round(sum(sf::st_length(csl)), 0))
expect_length <- nrow(pol) * 250
diff <- abs(1 - (total_length / expect_length))
expect_true(diff < 0.1)
buff <- clean_reach_buffer(center_line = center_line,
buffer_width = 100,
cross_section_lines = csl,
us_distance_colname = NA,
epsg = 26910)
# Test geometry type
test_geom <- as.character(unique(sf::st_geometry_type(buff)))
expect_true(test_geom == "POLYGON")
# Rows populated
expect_true(nrow(buff) > 0)
# Rows less than or equal to cross sections
expect_true(nrow(buff) <= nrow(csl))
# Fix order and test distance field
fix_order <- csl[order(csl$l_id, csl$p_id), ]
fix_order$us_distance_m <- cumsum(fix_order$distance_m)
# plot(fix_order['us_distance_m'])
csl <- fix_order
# Add variable length buffer
center_line$my_buffer <- rnorm(nrow(center_line)) * 20
center_line$my_buffer <- abs(center_line$my_buffer )
buff <- clean_reach_buffer(center_line = center_line,
buffer_width = "my_buffer",
cross_section_lines = csl,
us_distance_colname = 'us_distance_m',
epsg = 26910)
# Test geometry type
test_geom <- as.character(unique(sf::st_geometry_type(buff)))
expect_true(test_geom == "POLYGON")
# Rows populated
expect_true(nrow(buff) > 0)
# Rows less than or equal to cross sections
expect_true(nrow(buff) <= nrow(csl))
# or continue with default provided for tutorial
fname <- system.file("extdata", "bcfwa.gpkg", package="streamgis")
bcfwa <- sf::st_read(fname)
ds <- bcfwa_geometry(bcfwa = bcfwa,
upstream = 701794363,
downstream = 701773410,
epsg = 26910)
# Check names
names(ds)
expect_true(all(names(ds) == c("ds_path", "coordinates")))
expect_true(all(class(ds$ds_path) == c("sf", "data.frame")))
# View coordinates for longitudial profile
df <- ds$coordinates
dist1 <- tail(df$us_distance_m)[1]
dist2 <- sum(as.numeric(sf::st_length(ds$ds_path)))
diff <- abs(1 - dist1/dist2)
expect_true(diff < 0.05)
test_that("test cross sectional profiles", {
# Import a simple stream center line
# center_line <- st_read("./path/to/my/file.gpkg", layer = "layer name")
# or use default provided for tutorial
fname <- system.file("extdata", "center_line.gpkg", package="streamgis")
center_line <- sf::st_read(fname)
# plot(sf::st_geometry(center_line))
# Sample points along line
pol <- suppressWarnings({ points_on_line(center_line,
point_spacing = 100) })
# points <- pol
# plot(sf::st_geometry(center_line[center_line$id == 3, ]))
# plot(sf::st_geometry(pol[pol$l_id == 3, ]), add = TRUE, col = "red")
# Do distances make sense
diff <- pol$distance_m[6] - pol$distance_m[5]
expect_true(round(diff, 0) == 100)
# Do points start at origin
expect_true(round(pol$distance_m[2], 0) == 100)
# =============================================
# =============================================
# test  --- cross_section_lines
# =============================================
# =============================================
csl <- cross_section_lines(center_line = center_line,
points = pol,
cross_profile_length = 250,
epsg = 26910)
# plot(sf::st_geometry(center_line[center_line$id == 3, ]))
# plot(sf::st_geometry(pol[pol$l_id == 3, ]), add = TRUE, col = "red")
# plot(sf::st_geometry(csl[csl$l_id == 3, ]), add = TRUE, col = "blue")
# Test that total profile legnth is reasonable
total_length <- as.numeric(round(sum(sf::st_length(csl)), 0))
expect_length <- nrow(pol) * 250
diff <- abs(1 - (total_length / expect_length))
# diff <- abs(1 - (expect_length / total_length))
expect_true(diff < 0.1)
# =============================================
# =============================================
# test  --- clean_reach_buffer
# =============================================
# =============================================
buff <- clean_reach_buffer(center_line = center_line,
buffer_width = 100,
cross_section_lines = csl,
us_distance_colname = NA,
epsg = 26910)
# plot(sf::st_geometry(center_line[center_line$id == 3, ]))
# plot(sf::st_geometry(pol[pol$l_id == 3, ]), add = TRUE, col = "red")
# plot(sf::st_geometry(csl[csl$l_id == 3, ]), add = TRUE, col = "blue")
# plot(sf::st_geometry(buff[buff$l_id == 3, ]), add = TRUE, col = "grey")
# plot(sf::st_geometry(csl[csl$l_id == 3, ]), add = TRUE, col = "blue")
# Test geometry type
test_geom <- as.character(unique(sf::st_geometry_type(buff)))
expect_true(test_geom == "POLYGON")
# Rows populated
expect_true(nrow(buff) > 0)
# Rows less than or equal to cross sections
expect_true(nrow(buff) <= nrow(csl))
# Fix order and test distance field
fix_order <- csl[order(csl$l_id, csl$p_id), ]
fix_order$us_distance_m <- cumsum(fix_order$distance_m)
# plot(fix_order['us_distance_m'])
csl <- fix_order
# Add variable length buffer
center_line$my_buffer <- rnorm(nrow(center_line)) * 20
center_line$my_buffer <- abs(center_line$my_buffer )
buff <- clean_reach_buffer(center_line = center_line,
buffer_width = "my_buffer",
cross_section_lines = csl,
us_distance_colname = 'us_distance_m',
epsg = 26910)
# plot(sf::st_geometry(center_line[center_line$id == 3, ]))
# plot(sf::st_geometry(pol[pol$l_id == 3, ]), add = TRUE, col = "red")
# plot(sf::st_geometry(csl[csl$l_id == 3, ]), add = TRUE, col = "blue")
# plot(sf::st_geometry(buff[buff$l_id == 3, ]), add = TRUE, col = "grey")
# plot(sf::st_geometry(csl[csl$l_id == 3, ]), add = TRUE, col = "blue")
# Test geometry type
test_geom <- as.character(unique(sf::st_geometry_type(buff)))
expect_true(test_geom == "POLYGON")
# Rows populated
expect_true(nrow(buff) > 0)
# Rows less than or equal to cross sections
expect_true(nrow(buff) <= nrow(csl))
# =============================================
# =============================================
# test  --- bcfwa_geometry
# =============================================
# =============================================
# or continue with default provided for tutorial
fname <- system.file("extdata", "bcfwa.gpkg", package="streamgis")
bcfwa <- sf::st_read(fname)
ds <- bcfwa_geometry(bcfwa = bcfwa,
upstream = 701794363,
downstream = 701773410,
epsg = 26910)
# Check names
names(ds)
expect_true(all(names(ds) == c("ds_path", "coordinates")))
expect_true(all(class(ds$ds_path) == c("sf", "data.frame")))
# View coordinates for longitudial profile
df <- ds$coordinates
dist1 <- tail(df$us_distance_m)[1]
dist2 <- sum(as.numeric(sf::st_length(ds$ds_path)))
diff <- abs(1 - dist1/dist2)
expect_true(diff < 0.05)
})
#--------------------------------------
library(devtools)
# =====================================
# Rebuild Package
rm(list = ls())
devtools::load_all()
devtools::document()
devtools::check(vignettes = FALSE, manual = FALSE) # Operating system test
